// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Enums
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum Visibility {
  PUBLIC
  FOLLOWERS
  PRIVATE
}

enum ContentStatus {
  ACTIVE
  HIDDEN
  REMOVED
}

enum ReactionKind {
  LIKE
  SUPPORT
  HELPFUL
  PROUD
}

enum PostType {
  GENERAL
  ASSISTIVE_WIN
  RECOMMENDATION
  QUESTION
}

enum RecommendationKind {
  DOCTOR
  FACILITY
  EXERCISE
  DIET
  DEVICE
}

enum ReportStatus {
  OPEN
  TRIAGED
  ACTIONED
  DISMISSED
}

enum ModerationActionType {
  HIDE
  WARN
  BAN
  DELETE
}

enum SubjectType {
  POST
  COMMENT
  USER
  RECOMMENDATION
  MESSAGE
}

enum NotificationType {
  NEW_FOLLOW
  NEW_COMMENT
  NEW_REACTION
  NEW_MESSAGE
  MODERATION
  SYSTEM
}

enum UserRole {
  MEMBER
  MODERATOR
  ADMIN
}

enum ProfileType {
  NORMAL
  DOCTOR
  PT
  PARENT
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  SHADOWBANNED
  DELETED
}

// CP-specific enums
enum CPSubtype {
  SPASTIC
  DYSKINETIC
  ATAXIC
  MIXED
  UNKNOWN
}

enum GMFCS {
  I
  II
  III
  IV
  V
  UNKNOWN
}

enum MobilityAid {
  NONE
  CANE
  WALKER
  MANUAL_CHAIR
  POWER_CHAIR
  ANKLE_FOOT_ORTHOSIS
  OTHER
}

enum AssistiveTech {
  SPEECH_DEVICE
  EYETRACKER
  SWITCH_CONTROL
  HEADPOINTER
  VOICE_CONTROL
  SCREEN_READER
  ALT_KEYBOARD
  OTHER
}

enum CommMode {
  TYPING
  VOICE
  TEXT_TO_SPEECH
  AAC
  GESTURES
}

enum Transport {
  PUBLIC_TRANSIT
  RIDE_SHARE
  ADAPTED_VAN
  PARATRANSIT
  FAMILY
  FRIENDS
  OTHER
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Models
// Notes:
// - We store auth user id as UUID. For Supabase, this matches auth.users.id
// - `@default(dbgenerated("gen_random_uuid()"))` needs pgcrypto: CREATE EXTENSION IF NOT EXISTS pgcrypto;
// - `updatedAt @updatedAt` automatically manages timestamps via Prisma
// - Array columns use Postgres-native arrays via Prisma (e.g., String[])
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model User {
  id            String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  username      String?    @unique @db.Text
  password      String?    @db.Text
  email         String?    @unique @db.Text
  emailVerified DateTime?
  dateOfBirth   DateTime?
  name          String?    @db.Text
  firstName     String?    @db.Text
  lastName      String?    @db.Text
  image         String?    @db.Text
  passkeyEnrolled Boolean  @default(false)
  lastLoginAt   DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Admin fields
  role          UserRole   @default(MEMBER)
  status        UserStatus @default(ACTIVE)
  suspendedUntil DateTime?
  suspensionReason String?  @db.Text

  profile       Profile?
  posts         Post[]
  comments      Comment[]
  reactions     Reaction[]
  follows       Follow[]   @relation("follows_follower")
  followers     Follow[]   @relation("follows_followee")
  recommendations Recommendation[]
  recommendationReviews RecommendationReview[]
  messageThreadsCreated MessageThread[] @relation("threads_created_by")
  messages      Message[]
  reports       Report[]   @relation("reports_reporter")
  moderationActions ModerationAction[] @relation("moderation_actions_actor")
  notifications Notification[]
  auditLogs     AuditLog[] @relation("audit_logs_actor")
  verificationRequest VerificationRequest?

  // NextAuth adapter fields
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}

model Account {
  id                String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionToken String   @unique
  userId       String   @db.Uuid
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Profile {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @unique @db.Uuid

  displayName String?  @unique @db.Text
  pronouns    String?  @db.Text
  bio         String?  @db.Text
  region      String?  @db.Text  // free-form city/region; keep optional for privacy
  city        String   @default("") @db.Text
  state       String   @default("") @db.Text
  zip         String   @default("") @db.Text
  latitude    Decimal? @db.Decimal(10, 8)
  longitude   Decimal? @db.Decimal(11, 8)
  photos      String[] @default([]) @db.Text  // array of photo URLs

  // Profile type and verification
  profileType  ProfileType @default(NORMAL)
  isVerified   Boolean     @default(false)
  verifiedAt   DateTime?
  credentials  String?     @db.Text // Encrypted storage for credential documents

  // CP-specific fields
  cpSubtype   CPSubtype?    @default(UNKNOWN)
  gmfcs       GMFCS?        @default(UNKNOWN)
  mobilityAids     MobilityAid[]   @default([])
  assistiveTech    AssistiveTech[] @default([])
  commModes        CommMode[]      @default([])
  exerciseTolerance Int?           // 1-5 scale
  bestTimes        String[]   @default([]) @db.Text  // e.g., ["MORNING","AFTERNOON"]
  transport        Transport? @default(OTHER)

  // Accessibility preferences
  a11yPrefs   Json?  // {fontSize:'md/lg', contrast:'high', reduceMotion:true, dyslexiaFont:true}

  // Per-field visibility (JSON map)
  visibility  Json?  // {bio:'PUBLIC', region:'FOLLOWERS', gmfcs:'PRIVATE', ...}

  // Badges
  badges      String[] @default([]) @db.Text  // ['18_PLUS','ACCESSIBILITY_ADVOCATE','FIRST_POST','REC_HELPER']

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("profiles")
}

model Follow {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  followerId  String @db.Uuid
  followeeId  String @db.Uuid
  createdAt   DateTime @default(now())

  follower    User   @relation("follows_follower", fields: [followerId], references: [id], onDelete: Cascade)
  followee    User   @relation("follows_followee", fields: [followeeId], references: [id], onDelete: Cascade)

  @@unique([followerId, followeeId])
  @@index([followerId])
  @@index([followeeId])
  @@map("follows")
}

model Post {
  id          String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  authorId    String         @db.Uuid
  body        String         @db.Text
  images      String[]       @default([]) @db.Text
  cwLabel     String?        @db.Text
  visibility  Visibility     @default(PUBLIC)
  status      ContentStatus  @default(ACTIVE)

  // CP-specific enhancements
  postType    PostType       @default(GENERAL)
  energyLevel Int?           // 1-4 scale: 1=ğŸ˜´ low, 2=ğŸ˜ medium-low, 3=ğŸ™‚ medium-high, 4=ğŸ’ª high

  // Admin moderation fields
  isPinned    Boolean        @default(false)
  pinnedAt    DateTime?
  pinnedBy    String?        @db.Text // Admin username who pinned it

  author      User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tags        PostTag[]
  comments    Comment[]
  reactions   Reaction[]     @relation("reaction_post")
  reports     Report[]       @relation("reports_post")

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([authorId, createdAt(sort: Desc)])
  @@map("posts")
}

model PostTag {
  id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId  String @db.Uuid
  tag     String @db.Text

  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([tag])
  @@unique([postId, tag])
  @@map("post_tags")
}

model Comment {
  id          String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId      String        @db.Uuid
  authorId    String        @db.Uuid
  parentId    String?       @db.Uuid
  body        String        @db.Text
  status      ContentStatus @default(ACTIVE)

  post        Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  author      User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent      Comment?      @relation("comment_parent", fields: [parentId], references: [id], onDelete: Cascade)
  children    Comment[]     @relation("comment_parent")
  reactions   Reaction[]    @relation("reaction_comment")
  reports     Report[]      @relation("reports_comment")

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([postId])
  @@index([authorId, createdAt(sort: Desc)])
  @@map("comments")
}

model Reaction {
  id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String       @db.Uuid
  kind        ReactionKind

  // Polymorphic target: either Post or Comment (one of the FKs must be set)
  postId      String?      @db.Uuid
  commentId   String?      @db.Uuid

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  post        Post?        @relation("reaction_post", fields: [postId], references: [id], onDelete: Cascade)
  comment     Comment?     @relation("reaction_comment", fields: [commentId], references: [id], onDelete: Cascade)

  createdAt   DateTime     @default(now())

  @@unique([userId, postId, commentId], map: "uniq_reaction_per_subject")
  @@index([postId])
  @@index([commentId])
  @@map("reactions")
}

model Recommendation {
  id          String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  kind        RecommendationKind
  title       String              @db.Text
  body        String              @db.Text
  authorId    String              @db.Uuid
  region      String?             @db.Text
  url         String?             @db.Text
  meta        Json?               // flexible fields per kind (e.g., difficulty, body_area, cost)
  status      ContentStatus       @default(ACTIVE)

  author      User                @relation(fields: [authorId], references: [id], onDelete: Cascade)
  reviews     RecommendationReview[]
  reports     Report[]            @relation("reports_recommendation")

  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@index([kind])
  @@index([authorId, createdAt(sort: Desc)])
  @@map("recommendations")
}

model RecommendationReview {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  recommendationId  String   @db.Uuid
  reviewerId        String   @db.Uuid
  rating            Int
  notes             String?  @db.Text

  recommendation    Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  reviewer          User           @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  createdAt         DateTime @default(now())

  @@unique([recommendationId, reviewerId])
  @@index([reviewerId])
  @@map("recommendation_reviews")
}

model MessageThread {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdById String   @db.Uuid
  isBlocked   Boolean  @default(false)

  createdBy   User     @relation("threads_created_by", fields: [createdById], references: [id], onDelete: Cascade)
  messages    Message[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("message_threads")
}

model Message {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  threadId   String   @db.Uuid
  senderId   String   @db.Uuid
  body       String   @db.Text
  attachments String[] @default([]) @db.Text

  thread     MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender     User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reports    Report[]      @relation("reports_message")

  createdAt  DateTime  @default(now())

  @@index([threadId, createdAt(sort: Desc)])
  @@index([senderId])
  @@map("messages")
}

model Report {
  id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  subjectType SubjectType
  subjectId   String       @db.Uuid
  reporterId  String       @db.Uuid
  reason      String       @db.Text
  status      ReportStatus @default(OPEN)

  reporter    User         @relation("reports_reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  moderationActions ModerationAction[]

  // Polymorphic relations (optional, helps with type safety)
  post        Post?        @relation("reports_post", fields: [subjectId], references: [id], onDelete: Cascade, map: "fk_reports_post")
  comment     Comment?     @relation("reports_comment", fields: [subjectId], references: [id], onDelete: Cascade, map: "fk_reports_comment")
  recommendation Recommendation? @relation("reports_recommendation", fields: [subjectId], references: [id], onDelete: Cascade, map: "fk_reports_recommendation")
  message     Message?     @relation("reports_message", fields: [subjectId], references: [id], onDelete: Cascade, map: "fk_reports_message")

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([subjectType, subjectId])
  @@index([reporterId])
  @@map("reports")
}

model ModerationAction {
  id          String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  reportId    String               @db.Uuid
  actorId     String               @db.Uuid
  action      ModerationActionType
  notes       String?              @db.Text

  report      Report               @relation(fields: [reportId], references: [id], onDelete: Cascade)
  actor       User                 @relation("moderation_actions_actor", fields: [actorId], references: [id], onDelete: Cascade)

  createdAt   DateTime             @default(now())

  @@index([reportId])
  @@index([actorId])
  @@map("moderation_actions")
}

model Notification {
  id        String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String           @db.Uuid
  type      NotificationType
  payload   Json
  readAt    DateTime?

  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime         @default(now())

  @@index([userId, createdAt(sort: Desc)])
  @@map("notifications")
}

model AuditLog {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  actorId     String?  @db.Uuid
  action      String   @db.Text
  targetType  String   @db.Text
  targetId    String?  @db.Uuid
  detail      Json?
  ipAddress   String?  @db.Text
  userAgent   String?  @db.Text

  actor       User?    @relation("audit_logs_actor", fields: [actorId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())

  @@index([actorId])
  @@index([targetType, targetId])
  @@index([action])
  @@index([createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Admin-specific models

model ContentFilter {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  pattern     String   @db.Text
  type        String   @db.Text // "keyword", "link", "regex"
  action      String   @db.Text // "flag", "auto-remove", "shadowban"
  isActive    Boolean  @default(true)
  reason      String?  @db.Text

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type, isActive])
  @@map("content_filters")
}

model SystemAnnouncement {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title       String   @db.Text
  message     String   @db.Text
  type        String   @db.Text // "info", "warning", "maintenance"
  targetRole  String?  @db.Text // null = all, "MEMBER", "MODERATOR", "ADMIN"
  isActive    Boolean  @default(true)
  startsAt    DateTime?
  endsAt      DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive, startsAt, endsAt])
  @@map("system_announcements")
}

model FeatureFlag {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key         String   @unique @db.Text
  isEnabled   Boolean  @default(false)
  description String?  @db.Text
  config      Json?    // Additional configuration

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("feature_flags")
}

model ModNote {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  contentType   String   @db.Text // "POST" or "COMMENT"
  contentId     String   @db.Uuid
  note          String   @db.Text
  adminUsername String   @db.Text
  adminName     String?  @db.Text

  createdAt     DateTime @default(now())

  @@index([contentType, contentId])
  @@index([createdAt(sort: Desc)])
  @@map("mod_notes")
}

model DataExportRequest {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @db.Uuid
  status      String   @db.Text // "pending", "processing", "completed", "failed"
  format      String   @db.Text // "json", "csv"
  downloadUrl String?  @db.Text
  expiresAt   DateTime?

  createdAt   DateTime @default(now())
  completedAt DateTime?

  @@index([userId, status])
  @@map("data_export_requests")
}

model VerificationRequest {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId           String    @unique @db.Uuid
  role             String    @db.Text // "MD", "DO", "PA", "PT"
  npi              String?   @db.Text
  licenseNumber    String    @db.Text
  licenseState     String    @db.Text
  evidenceFileUrl  String?   @db.Text
  evidenceFileName String?   @db.Text
  websiteUrl       String?   @db.Text
  status           String    @default("PENDING") @db.Text // "PENDING", "APPROVED", "REJECTED", "MORE_INFO_NEEDED"
  notes            String?   @db.Text // User's notes
  adminNotes       String?   @db.Text // Admin's internal notes
  source           Json?     // NPI lookup results and verification data
  reviewedBy       String?   @db.Text // Admin username
  reviewedAt       DateTime?

  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([role])
  @@map("verification_requests")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Admin System (Separate from User Accounts)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model Admin {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  username  String   @unique @db.Text
  password  String   @db.Text // bcrypt hashed
  email     String   @unique @db.Text
  name      String   @db.Text

  isActive  Boolean  @default(true)
  isSuperAdmin Boolean @default(false) // Super admins can create other admins

  lastLoginAt DateTime?
  lastLoginIp String?  @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions AdminSession[]

  @@index([username])
  @@index([isActive])
  @@map("admins")
}

model AdminSession {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  adminId   String   @db.Uuid
  token     String   @unique @db.Text
  expiresAt DateTime
  ipAddress String?  @db.Text
  userAgent String?  @db.Text

  createdAt DateTime @default(now())

  admin     Admin    @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([token])
  @@index([expiresAt])
  @@map("admin_sessions")
}